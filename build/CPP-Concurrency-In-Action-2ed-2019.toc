
\contentsline {section}{{}\hspace {0.5cm}{C++ Concurrency In Action}}{10}{section*.2}%
\contentsline {subsubsection}{{}\hspace {0.2cm}{本书概述}}{10}{section*.3}%
\contentsline {subsubsection}{{}\hspace {0.2cm}{技术方面}}{10}{section*.4}%
\contentsline {subsubsection}{{}\hspace {0.2cm}{关于本书}}{10}{section*.5}%
\contentsline {subsubsection}{{}\hspace {0.2cm}{内容概述}}{10}{section*.6}%
\contentsline {subsubsection}{{}\hspace {0.2cm}{读者须知}}{11}{section*.7}%
\contentsline {subsubsection}{{}\hspace {0.2cm}{本书相关}}{11}{section*.8}%
\contentsline {section}{{}\hspace {0.5cm}{第一版的赞许}}{12}{section*.9}%
\contentsline {section}{{}\hspace {0.5cm}{前言}}{13}{section*.10}%
\contentsline {section}{{}\hspace {0.5cm}{感谢}}{14}{section*.11}%
\contentsline {section}{{}\hspace {0.5cm}{关于本书}}{15}{section*.12}%
\contentsline {subsection}{{}\hspace {0.2cm}{路线图}}{15}{section*.13}%
\contentsline {subsection}{{}\hspace {0.2cm}{适读人群}}{15}{section*.14}%
\contentsline {subsubsection}{{}\hspace {0.2cm}{如何阅读本书}}{15}{section*.15}%
\contentsline {subsection}{{}\hspace {0.2cm}{代码公约和下载}}{16}{section*.16}%
\contentsline {subsubsection}{{}\hspace {0.2cm}{软件需求}}{16}{section*.17}%
\contentsline {subsection}{{}\hspace {0.2cm}{作者在线}}{16}{section*.18}%
\contentsline {section}{{}\hspace {0.5cm}{关于作者}}{17}{section*.19}%
\contentsline {section}{{}\hspace {0.5cm}{关于封面}}{18}{section*.20}%
\contentsline {subsubsection}{{}\hspace {0.2cm}{封面图片介绍}}{18}{section*.21}%
\contentsline {section}{{第1章}\hspace {0.5cm}{你好，并发世界}}{19}{section*.22}%
\contentsline {subsection}{{1.1.}\hspace {0.2cm}{何谓并发}}{19}{section*.23}%
\contentsline {subsubsection}{{1.1.1}\hspace {0.2cm}{计算机的并发}}{19}{section*.24}%
\contentsline {subsubsection}{{1.1.2}\hspace {0.2cm}{并发的方式}}{20}{section*.25}%
\contentsline {subsubsection}{{1.1.3}\hspace {0.2cm}{并发与并行}}{22}{section*.26}%
\contentsline {subsection}{{1.2.}\hspace {0.2cm}{为什么使用并发}}{22}{section*.27}%
\contentsline {subsubsection}{{1.2.1}\hspace {0.2cm}{分离关注点}}{23}{section*.28}%
\contentsline {subsubsection}{{1.2.2}\hspace {0.2cm}{性能}}{23}{section*.29}%
\contentsline {subsubsection}{{1.2.3}\hspace {0.2cm}{什么时候不使用并发}}{24}{section*.30}%
\contentsline {subsection}{{1.3.}\hspace {0.2cm}{并发和多线程}}{24}{section*.31}%
\contentsline {subsubsection}{{1.3.1}\hspace {0.2cm}{C++多线程历史}}{25}{section*.32}%
\contentsline {subsubsection}{{1.3.2}\hspace {0.2cm}{支持并发}}{25}{section*.33}%
\contentsline {subsubsection}{{1.3.3}\hspace {0.2cm}{C++14和C++17对并发和并行的更多支持}}{25}{section*.34}%
\contentsline {subsubsection}{{1.3.4}\hspace {0.2cm}{C++线程库的效率}}{26}{section*.35}%
\contentsline {subsubsection}{{1.3.5}\hspace {0.2cm}{平台相关的工具}}{26}{section*.36}%
\contentsline {subsection}{{1.4.}\hspace {0.2cm}{开始入门}}{26}{section*.37}%
\contentsline {subsubsection}{{1.4.1}\hspace {0.2cm}{欢迎来到并发世界}}{27}{section*.38}%
\contentsline {subsection}{{1.5.}\hspace {0.2cm}{本章总结}}{28}{section*.39}%
\contentsline {section}{{第2章}\hspace {0.5cm}{线程管理}}{29}{section*.40}%
\contentsline {subsection}{{2.1.}\hspace {0.2cm}{线程的基本操作}}{29}{section*.41}%
\contentsline {subsubsection}{{2.1.1}\hspace {0.2cm}{启动线程}}{29}{section*.42}%
\contentsline {subsubsection}{{2.1.2}\hspace {0.2cm}{等待线程完成}}{31}{section*.43}%
\contentsline {subsubsection}{{2.1.3}\hspace {0.2cm}{特殊情况下的等待}}{32}{section*.44}%
\contentsline {subsubsection}{{2.1.4}\hspace {0.2cm}{后台运行线程}}{33}{section*.45}%
\contentsline {subsection}{{2.2.}\hspace {0.2cm}{传递参数}}{35}{section*.46}%
\contentsline {subsection}{{2.3.}\hspace {0.2cm}{转移所有权}}{37}{section*.47}%
\contentsline {subsection}{{2.4.}\hspace {0.2cm}{确定线程数量}}{41}{section*.48}%
\contentsline {subsection}{{2.5.}\hspace {0.2cm}{线程标识}}{43}{section*.49}%
\contentsline {subsection}{{2.6.}\hspace {0.2cm}{本章总结}}{44}{section*.50}%
\contentsline {section}{{第3章}\hspace {0.5cm}{共享数据}}{46}{section*.51}%
\contentsline {subsection}{{3.1.}\hspace {0.2cm}{共享数据的问题}}{46}{section*.52}%
\contentsline {subsubsection}{{3.1.1}\hspace {0.2cm}{条件竞争}}{47}{section*.53}%
\contentsline {subsubsection}{{3.1.2}\hspace {0.2cm}{避免恶性条件竞争}}{48}{section*.54}%
\contentsline {subsection}{{3.2.}\hspace {0.2cm}{使用互斥量}}{48}{section*.55}%
\contentsline {subsubsection}{{3.2.1}\hspace {0.2cm}{互斥量}}{49}{section*.56}%
\contentsline {subsubsection}{{3.2.2}\hspace {0.2cm}{保护共享数据}}{50}{section*.57}%
\contentsline {subsubsection}{{3.2.3}\hspace {0.2cm}{接口间的条件竞争}}{51}{section*.58}%
\contentsline {subsubsection}{{3.2.4}\hspace {0.2cm}{死锁：问题描述及解决方案}}{57}{section*.59}%
\contentsline {subsubsection}{{3.2.5}\hspace {0.2cm}{避免死锁的进阶指导}}{59}{section*.60}%
\contentsline {subsubsection}{{3.2.6}\hspace {0.2cm}{std::unique\_lock——灵活的锁}}{64}{section*.61}%
\contentsline {subsubsection}{{3.2.7}\hspace {0.2cm}{不同域中互斥量的传递}}{65}{section*.62}%
\contentsline {subsubsection}{{3.2.8}\hspace {0.2cm}{锁的粒度}}{66}{section*.63}%
\contentsline {subsection}{{3.3.}\hspace {0.2cm}{保护共享数据的方式}}{68}{section*.64}%
\contentsline {subsubsection}{{3.3.1}\hspace {0.2cm}{保护共享数据的初始化过程}}{68}{section*.65}%
\contentsline {subsubsection}{{3.3.2}\hspace {0.2cm}{保护不常更新的数据结构}}{71}{section*.66}%
\contentsline {subsubsection}{{3.3.3}\hspace {0.2cm}{嵌套锁}}{73}{section*.67}%
\contentsline {subsection}{{3.4.}\hspace {0.2cm}{本章总结}}{73}{section*.68}%
\contentsline {section}{{第4章}\hspace {0.5cm}{同步操作}}{75}{section*.69}%
\contentsline {subsection}{{4.1.}\hspace {0.2cm}{等待事件或条件}}{75}{section*.70}%
\contentsline {subsubsection}{{4.1.1}\hspace {0.2cm}{等待条件达成}}{76}{section*.71}%
\contentsline {subsubsection}{{4.1.2}\hspace {0.2cm}{构建线程安全队列}}{78}{section*.72}%
\contentsline {subsection}{{4.2.}\hspace {0.2cm}{使用future}}{83}{section*.73}%
\contentsline {subsubsection}{{4.2.1}\hspace {0.2cm}{后台任务的返回值}}{83}{section*.74}%
\contentsline {subsubsection}{{4.2.2}\hspace {0.2cm}{future与任务关联}}{85}{section*.75}%
\contentsline {subsubsection}{{4.2.3}\hspace {0.2cm}{使用std::promises}}{88}{section*.76}%
\contentsline {subsubsection}{{4.2.4}\hspace {0.2cm}{将异常存与future中}}{89}{section*.77}%
\contentsline {subsubsection}{{4.2.5}\hspace {0.2cm}{多个线程的等待}}{91}{section*.78}%
\contentsline {subsection}{{4.3.}\hspace {0.2cm}{限时等待}}{93}{section*.79}%
\contentsline {subsubsection}{{4.3.1}\hspace {0.2cm}{时钟}}{93}{section*.80}%
\contentsline {subsubsection}{{4.3.2}\hspace {0.2cm}{时间段}}{94}{section*.81}%
\contentsline {subsubsection}{{4.3.3}\hspace {0.2cm}{时间点}}{95}{section*.82}%
\contentsline {subsubsection}{{4.3.4}\hspace {0.2cm}{使用超时}}{96}{section*.83}%
\contentsline {subsection}{{4.4.}\hspace {0.2cm}{简化代码}}{97}{section*.84}%
\contentsline {subsubsection}{{4.4.1}\hspace {0.2cm}{使用future的函数化编程}}{98}{section*.85}%
\contentsline {subsubsection}{{4.4.2}\hspace {0.2cm}{使用消息传递的同步操作}}{101}{section*.86}%
\contentsline {subsubsection}{{4.4.3}\hspace {0.2cm}{扩展规范中的持续性并发}}{105}{section*.87}%
\contentsline {subsubsection}{{4.4.4}\hspace {0.2cm}{持续性连接}}{106}{section*.88}%
\contentsline {subsubsection}{{4.4.5}\hspace {0.2cm}{等待多个future}}{109}{section*.89}%
\contentsline {subsubsection}{{4.4.6}\hspace {0.2cm}{使用when\_any等待第一个future}}{111}{section*.90}%
\contentsline {subsubsection}{{4.4.7}\hspace {0.2cm}{锁存器和栅栏}}{113}{section*.91}%
\contentsline {subsubsection}{{4.4.8}\hspace {0.2cm}{std::experimental::latch：基础的锁存器类型}}{114}{section*.92}%
\contentsline {subsubsection}{{4.4.9}\hspace {0.2cm}{std::experimental::barrier：简单的栅栏}}{115}{section*.93}%
\contentsline {subsubsection}{{4.4.10}\hspace {0.2cm}{std::experimental::flex\_barrier—更灵活和更友好的std::experimental::barrier}}{116}{section*.94}%
\contentsline {subsection}{{4.5.}\hspace {0.2cm}{本章总结}}{117}{section*.95}%
\contentsline {section}{{第5章}\hspace {0.5cm}{内存模型和原子操作}}{119}{section*.96}%
\contentsline {subsection}{{5.1.}\hspace {0.2cm}{内存模型}}{119}{section*.97}%
\contentsline {subsubsection}{{5.1.1}\hspace {0.2cm}{对象和内存位置}}{119}{section*.98}%
\contentsline {subsubsection}{{5.1.2}\hspace {0.2cm}{对象、内存位置和并发}}{120}{section*.99}%
\contentsline {subsubsection}{{5.1.3}\hspace {0.2cm}{修改顺序}}{121}{section*.100}%
\contentsline {subsection}{{5.2.}\hspace {0.2cm}{原子操作和原子类型}}{121}{section*.101}%
\contentsline {subsubsection}{{5.2.1}\hspace {0.2cm}{标准原子类型}}{121}{section*.102}%
\contentsline {subsubsection}{{5.2.2}\hspace {0.2cm}{std::atomic\_flag}}{123}{section*.103}%
\contentsline {subsubsection}{{5.2.3}\hspace {0.2cm}{\texttt {std::atomic<bool>}}}{124}{section*.104}%
\contentsline {subsubsection}{{5.2.4}\hspace {0.2cm}{\texttt {std::atomic<T*>}}}{126}{section*.105}%
\contentsline {subsubsection}{{5.2.5}\hspace {0.2cm}{标准原子整型的相关操作}}{127}{section*.106}%
\contentsline {subsubsection}{{5.2.6}\hspace {0.2cm}{\texttt {std::atomic<>}类模板}}{128}{section*.107}%
\contentsline {subsubsection}{{5.2.7}\hspace {0.2cm}{原子操作的非成员函数}}{129}{section*.108}%
\contentsline {subsection}{{5.3.}\hspace {0.2cm}{同步操作和强制排序}}{130}{section*.109}%
\contentsline {subsubsection}{{5.3.1}\hspace {0.2cm}{同步发生}}{132}{section*.110}%
\contentsline {subsubsection}{{5.3.2}\hspace {0.2cm}{先行发生}}{132}{section*.111}%
\contentsline {subsubsection}{{5.3.3}\hspace {0.2cm}{原子操作的内存序}}{134}{section*.112}%
\contentsline {subsubsection}{{5.3.4}\hspace {0.2cm}{释放队列与同步}}{148}{section*.113}%
\contentsline {subsubsection}{{5.3.5}\hspace {0.2cm}{栅栏}}{150}{section*.114}%
\contentsline {subsubsection}{{5.3.6}\hspace {0.2cm}{原子操作对非原子的操作排序}}{152}{section*.115}%
\contentsline {subsubsection}{{5.3.7}\hspace {0.2cm}{非原子操作排序}}{153}{section*.116}%
\contentsline {subsection}{{5.4.}\hspace {0.2cm}{本章总结}}{155}{section*.117}%
\contentsline {section}{{第6章}\hspace {0.5cm}{设计基于锁的并发数据结构}}{157}{section*.118}%
\contentsline {subsection}{{6.1.}\hspace {0.2cm}{并发设计的意义}}{157}{section*.119}%
\contentsline {subsubsection}{{6.1.1}\hspace {0.2cm}{并发数据结构设计的指南}}{157}{section*.120}%
\contentsline {subsection}{{6.2.}\hspace {0.2cm}{基于锁的并发数据结构}}{158}{section*.121}%
\contentsline {subsubsection}{{6.2.1}\hspace {0.2cm}{线程安全栈——使用锁}}{158}{section*.122}%
\contentsline {subsubsection}{{6.2.2}\hspace {0.2cm}{线程安全队列——使用锁和条件变量}}{160}{section*.123}%
\contentsline {subsubsection}{{6.2.3}\hspace {0.2cm}{线程安全队列——使用细粒度锁和条件变量}}{164}{section*.124}%
\contentsline {subsection}{{6.3.}\hspace {0.2cm}{设计更加复杂的数据结构}}{175}{section*.125}%
\contentsline {subsubsection}{{6.3.1}\hspace {0.2cm}{使用锁的线程安全查询表}}{175}{section*.126}%
\contentsline {subsubsection}{{6.3.2}\hspace {0.2cm}{编写使用锁的线程安全链表}}{179}{section*.127}%
\contentsline {subsection}{{6.4.}\hspace {0.2cm}{本章总结}}{183}{section*.128}%
\contentsline {section}{{第7章}\hspace {0.5cm}{设计无锁的并发数据结构}}{184}{section*.129}%
\contentsline {subsection}{{7.1.}\hspace {0.2cm}{定义和意义}}{184}{section*.130}%
\contentsline {subsubsection}{{7.1.1}\hspace {0.2cm}{非阻塞数据结构}}{184}{section*.131}%
\contentsline {subsubsection}{{7.1.2}\hspace {0.2cm}{无锁数据结构}}{185}{section*.132}%
\contentsline {subsubsection}{{7.1.3}\hspace {0.2cm}{无等待数据结构}}{185}{section*.133}%
\contentsline {subsubsection}{{7.1.4}\hspace {0.2cm}{无锁数据结构的利与弊}}{186}{section*.134}%
\contentsline {subsection}{{7.2.}\hspace {0.2cm}{无锁数据结构的例子}}{187}{section*.135}%
\contentsline {subsubsection}{{7.2.1}\hspace {0.2cm}{实现一个无锁的线程安全栈}}{187}{section*.136}%
\contentsline {subsubsection}{{7.2.2}\hspace {0.2cm}{终止内存泄露：使用无锁数据结构管理内存}}{190}{section*.137}%
\contentsline {subsubsection}{{7.2.3}\hspace {0.2cm}{使用风险指针检测不可回收的节点}}{193}{section*.138}%
\contentsline {subsubsection}{{7.2.4}\hspace {0.2cm}{使用引用计数}}{200}{section*.139}%
\contentsline {subsubsection}{{7.2.5}\hspace {0.2cm}{无锁栈上的内存模型}}{205}{section*.140}%
\contentsline {subsubsection}{{7.2.6}\hspace {0.2cm}{实现一个无锁的线程安全队列}}{209}{section*.141}%
\contentsline {subsection}{{7.3.}\hspace {0.2cm}{设计无锁数据结构的指导建议}}{220}{section*.142}%
\contentsline {subsubsection}{{7.3.1}\hspace {0.2cm}{指导建议：使用\texttt {std::memory\_order\_seq\_cst}}}{220}{section*.143}%
\contentsline {subsubsection}{{7.3.2}\hspace {0.2cm}{指导建议：对无锁内存的回收}}{221}{section*.144}%
\contentsline {subsubsection}{{7.3.3}\hspace {0.2cm}{指导建议：小心\href {https://en.wikipedia.org/wiki/ABA_problem}{ABA问题}}}{221}{section*.145}%
\contentsline {subsubsection}{{7.3.4}\hspace {0.2cm}{指导建议：识别忙等待循环和帮助其他线程}}{222}{section*.146}%
\contentsline {subsection}{{7.4.}\hspace {0.2cm}{本章总结}}{222}{section*.147}%
\contentsline {section}{{第8章}\hspace {0.5cm}{并发设计}}{223}{section*.148}%
\contentsline {subsection}{{8.1.}\hspace {0.2cm}{线程间划分工作}}{223}{section*.149}%
\contentsline {subsubsection}{{8.1.1}\hspace {0.2cm}{对数据进行预处理划分}}{224}{section*.150}%
\contentsline {subsubsection}{{8.1.2}\hspace {0.2cm}{递归划分}}{225}{section*.151}%
\contentsline {subsubsection}{{8.1.3}\hspace {0.2cm}{通过任务类型划分}}{228}{section*.152}%
\contentsline {subsection}{{8.2.}\hspace {0.2cm}{并发代码的性能}}{230}{section*.153}%
\contentsline {subsubsection}{{8.2.1}\hspace {0.2cm}{处理器数量}}{230}{section*.154}%
\contentsline {subsubsection}{{8.2.2}\hspace {0.2cm}{数据争用与乒乓缓存}}{231}{section*.155}%
\contentsline {subsubsection}{{8.2.3}\hspace {0.2cm}{伪共享}}{232}{section*.156}%
\contentsline {subsubsection}{{8.2.4}\hspace {0.2cm}{让数据紧凑}}{233}{section*.157}%
\contentsline {subsubsection}{{8.2.5}\hspace {0.2cm}{超额申请和频繁的任务切换}}{233}{section*.158}%
\contentsline {subsection}{{8.3.}\hspace {0.2cm}{为多线程性能设计数据结构}}{234}{section*.159}%
\contentsline {subsubsection}{{8.3.1}\hspace {0.2cm}{划分数组元素}}{234}{section*.160}%
\contentsline {subsubsection}{{8.3.2}\hspace {0.2cm}{其他数据结构中的访问模式}}{235}{section*.161}%
\contentsline {subsection}{{8.4.}\hspace {0.2cm}{设计并发代码的注意事项}}{237}{section*.162}%
\contentsline {subsubsection}{{8.4.1}\hspace {0.2cm}{并行算法中的异常安全}}{237}{section*.163}%
\contentsline {subsubsection}{{8.4.2}\hspace {0.2cm}{可扩展性和Amdahl定律}}{243}{section*.164}%
\contentsline {subsubsection}{{8.4.3}\hspace {0.2cm}{使用多线程隐藏延迟}}{245}{section*.165}%
\contentsline {subsubsection}{{8.4.4}\hspace {0.2cm}{使用并发提高响应能力}}{245}{section*.166}%
\contentsline {subsection}{{8.5.}\hspace {0.2cm}{在实践中设计并发代码}}{247}{section*.167}%
\contentsline {subsubsection}{{8.5.1}\hspace {0.2cm}{并行版\texttt {std::for\_each}}}{247}{section*.168}%
\contentsline {subsubsection}{{8.5.2}\hspace {0.2cm}{并行版\texttt {std::find}}}{249}{section*.169}%
\contentsline {subsubsection}{{8.5.3}\hspace {0.2cm}{并行版\texttt {std::partial\_sum}}}{254}{section*.170}%
\contentsline {subsection}{{8.5.}\hspace {0.2cm}{本章总结}}{262}{section*.171}%
\contentsline {section}{{第9章}\hspace {0.5cm}{高级线程管理}}{263}{section*.172}%
\contentsline {subsection}{{9.1.}\hspace {0.2cm}{线程池}}{263}{section*.173}%
\contentsline {subsubsection}{{9.1.1}\hspace {0.2cm}{简单的线程池}}{263}{section*.174}%
\contentsline {subsubsection}{{9.1.2}\hspace {0.2cm}{等待线程池中的任务}}{265}{section*.175}%
\contentsline {subsubsection}{{9.1.3}\hspace {0.2cm}{等待依赖任务}}{269}{section*.176}%
\contentsline {subsubsection}{{9.1.4}\hspace {0.2cm}{避免队列中的任务竞争}}{271}{section*.177}%
\contentsline {subsubsection}{{9.1.5}\hspace {0.2cm}{窃取任务}}{273}{section*.178}%
\contentsline {subsection}{{9.2.}\hspace {0.2cm}{中断线程}}{277}{section*.179}%
\contentsline {subsubsection}{{9.2.1}\hspace {0.2cm}{启动和中断线程}}{277}{section*.180}%
\contentsline {subsubsection}{{9.2.2}\hspace {0.2cm}{检查线程是否中断}}{279}{section*.181}%
\contentsline {subsubsection}{{9.2.3}\hspace {0.2cm}{中断等待——条件变量}}{280}{section*.182}%
\contentsline {subsubsection}{{9.2.4}\hspace {0.2cm}{使用\texttt {std::condition\_variable\_any}中断等待}}{282}{section*.183}%
\contentsline {subsubsection}{{9.2.5}\hspace {0.2cm}{中断其他阻塞调用}}{284}{section*.184}%
\contentsline {subsubsection}{{9.2.6}\hspace {0.2cm}{处理中断}}{285}{section*.185}%
\contentsline {subsubsection}{{9.2.7}\hspace {0.2cm}{退出时中断后台任务}}{286}{section*.186}%
\contentsline {subsection}{{9.3.}\hspace {0.2cm}{本章总结}}{287}{section*.187}%
\contentsline {section}{{第10章}\hspace {0.5cm}{并行算法}}{288}{section*.188}%
\contentsline {subsection}{{10.1.}\hspace {0.2cm}{并行化标准库算法}}{288}{section*.189}%
\contentsline {subsection}{{10.2.}\hspace {0.2cm}{执行策略}}{288}{section*.190}%
\contentsline {subsubsection}{{10.2.1}\hspace {0.2cm}{使用执行策略的影响}}{289}{section*.191}%
\contentsline {subsubsection}{{10.2.2}\hspace {0.2cm}{std::execution::sequenced\_policy}}{289}{section*.192}%
\contentsline {subsubsection}{{10.2.3}\hspace {0.2cm}{std::execution::parallel\_policy}}{290}{section*.193}%
\contentsline {subsubsection}{{10.2.4}\hspace {0.2cm}{std::execution::parallel\_unsequenced\_policy}}{291}{section*.194}%
\contentsline {subsection}{{10.3.}\hspace {0.2cm}{C++标准库中的并行算法}}{291}{section*.195}%
\contentsline {subsubsection}{{10.3.1}\hspace {0.2cm}{并行算法示例}}{293}{section*.196}%
\contentsline {subsubsection}{{10.3.2}\hspace {0.2cm}{计数访问}}{295}{section*.197}%
\contentsline {subsection}{{10.4.}\hspace {0.2cm}{本章总结}}{296}{section*.198}%
\contentsline {section}{{第11章}\hspace {0.5cm}{多线程程序的测试和调试}}{297}{section*.199}%
\contentsline {subsection}{{11.1.}\hspace {0.2cm}{与并发相关的错误类型}}{297}{section*.200}%
\contentsline {subsubsection}{{11.1.1}\hspace {0.2cm}{不必要的阻塞}}{297}{section*.201}%
\contentsline {subsubsection}{{11.1.2}\hspace {0.2cm}{条件竞争}}{298}{section*.202}%
\contentsline {subsection}{{11.2.}\hspace {0.2cm}{定位并发Bug的技巧}}{299}{section*.203}%
\contentsline {subsubsection}{{11.2.1}\hspace {0.2cm}{代码评审——发现潜在的错误}}{299}{section*.204}%
\contentsline {subsubsection}{{11.2.2}\hspace {0.2cm}{定位并发相关的错误}}{300}{section*.205}%
\contentsline {subsubsection}{{11.2.3}\hspace {0.2cm}{可测试性设计}}{301}{section*.206}%
\contentsline {subsubsection}{{11.2.4}\hspace {0.2cm}{多线程测试技术}}{302}{section*.207}%
\contentsline {subsubsection}{{11.2.5}\hspace {0.2cm}{构建多线程测试代码}}{304}{section*.208}%
\contentsline {subsubsection}{{11.2.6}\hspace {0.2cm}{测试多线程代码性能}}{306}{section*.209}%
\contentsline {subsection}{{11.3.}\hspace {0.2cm}{本章总结}}{307}{section*.210}%
\contentsline {section}{{附录A}\hspace {0.5cm}{对C++11特性的简要介绍}}{308}{section*.211}%
\contentsline {subsection}{{A.1.}\hspace {0.2cm}{右值引用}}{308}{section*.212}%
\contentsline {subsubsection}{{A.1.1}\hspace {0.2cm}{移动语义}}{309}{section*.213}%
\contentsline {subsubsection}{{A.1.2}\hspace {0.2cm}{右值引用和函数模板}}{311}{section*.214}%
\contentsline {subsection}{{A.2.}\hspace {0.2cm}{删除函数}}{312}{section*.215}%
\contentsline {subsection}{{A.3.}\hspace {0.2cm}{右值引用}}{313}{section*.216}%
\contentsline {subsection}{{A.4.}\hspace {0.2cm}{常量表达式函数}}{316}{section*.217}%
\contentsline {subsubsection}{{A.4.1}\hspace {0.2cm}{常量表达式和自定义类型}}{317}{section*.218}%
\contentsline {subsubsection}{{A.4.2}\hspace {0.2cm}{常量表达式对象}}{320}{section*.219}%
\contentsline {subsubsection}{{A.4.3}\hspace {0.2cm}{常量表达式函数的要求}}{320}{section*.220}%
\contentsline {subsubsection}{{A.4.4}\hspace {0.2cm}{常量表达式和模板}}{321}{section*.221}%
\contentsline {subsection}{{A.5.}\hspace {0.2cm}{Lambda函数}}{321}{section*.222}%
\contentsline {subsubsection}{{A.5.1}\hspace {0.2cm}{引用本地变量的Lambda函数}}{323}{section*.223}%
\contentsline {subsection}{{A.6.}\hspace {0.2cm}{变参模板}}{326}{section*.224}%
\contentsline {subsubsection}{{A.6.1}\hspace {0.2cm}{扩展参数包}}{327}{section*.225}%
\contentsline {subsection}{{A.7.}\hspace {0.2cm}{自动推导变量类型}}{329}{section*.226}%
\contentsline {subsection}{{A.8.}\hspace {0.2cm}{线程本地变量}}{330}{section*.227}%
\contentsline {subsection}{{A.9.}\hspace {0.2cm}{模板类参数的推导}}{331}{section*.228}%
\contentsline {subsection}{{A.10.}\hspace {0.2cm}{本章总结}}{332}{section*.229}%
\contentsline {section}{{附录B}\hspace {0.5cm}{并发库的简单比较}}{333}{section*.230}%
\contentsline {section}{{附录C}\hspace {0.5cm}{消息传递框架与完整的ATM示例}}{335}{section*.231}%
\contentsline {section}{{附录D}\hspace {0.5cm}{C++线程库参考}}{354}{section*.232}%
